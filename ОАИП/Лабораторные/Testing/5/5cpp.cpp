#include <iostream>
using namespace std;
// Определение макросов для логических значений.
#define TRUE 1
#define FALSE 0
// Определение структуры для узлов бинарного дерева.
struct  node
{
    int Key; // Ключ узла.
    int Count; // Количество элементов в узле.
    node* Left; // Указатель на левого потомка.
    node* Right; // Указатель на правого потомка.
};

class TREE
{
private:
    node* Tree;//Указатель на корень дерева.
    node* Res;//Указатель на найденную вершину.
    int B; //Признак нахождения вершины в дереве.
    //Поиск вершины в дереве (рекурсивный алгоритм).
    void Search(int, node**); //Поиск звена x в бинарном дереве
    //вершина с заданным ключом имеет две исходящие дуги
    void Delete_1(node**, node**);
public:
    TREE() { Tree = NULL; }
    node** GetTree() { return &Tree; }
    void  BuildTree();//Построение бинарного дерева.
    //Вывод дерева на экран (рекурсивный алгоритм).
    void Vyvod(node**, int);
    //Поиск вершины в дереве (нерекурсивный алгоритм).
    int Poisk(int);
    //Поиск вершины в дереве (рекурсивный алгоритм).
    node* Poisk_1(int, node**);
    //Добавление вершины в дерево (нерекурсивный алгоритм).
    void Addition(int);
    // Удаление вершины из дерева.
    void Delete(node**, int);
};

void main()
{
    setlocale(LC_ALL, "Rus");// Установка русской локали.
    TREE A;// Создание объекта класса для работы с бинарным деревом.
    int el;// Переменная для хранения значения ключа.

    A.BuildTree(); // Построение бинарного дерева.
    A.Vyvod(A.GetTree(), 0);// Вывод дерева на экран.

    cout << "Введите ключ вершины, которую нужно найти в дереве: ";
    cin >> el;
    if (A.Poisk(el)) cout << "В дереве есть такая вершина!\n";// Поиск вершины.
    else  cout << "В дереве нет такой вершины!\n";
    cout << "Введите ключ вершины, которую нужно найти в дереве: ";
    cin >> el;
    if (A.Poisk_1(el, A.GetTree()) != NULL)//если вершина не найдена
        cout << "В дереве есть такая вершина!\n";
    else  cout << "В дереве нет такой вершины!\n";

    cout << "Введите ключ добавляемой вершины: ";
    cin >> el;
    A.Addition(el); //добавить вершину
    A.Vyvod(A.GetTree(), 0);//вывод

    cout << "Введите ключ удаляемой вершины: "; cin >> el;
    A.Delete(A.GetTree(), el);//удаление
    A.Vyvod(A.GetTree(), 0);//dsdjl

    cout << "\n";
    system("PAUSE");
}

void TREE::BuildTree()
//Построение бинарного дерева.
//Tree - указатель на вершину дерева.
{
    int el;

    cout << "Вводите ключи вершин дерева: \n";
    cin >> el;// Ввод ключей вершин дерева.
    // Пока пользователь не введет 0, продолжаем добавлять вершины.
    while (el != 0)
    {
        Search(el, &Tree); cin >> el;// Вызываем метод Search для поиска места вставки вершины с ключом el и вставляем ее в дерево.
    }
}

void TREE::Vyvod(node** w, int l)
//Изображение дерева w на экране дисплея
//         (рекурсивный алгоритм).
//*w - указатель на корень дерева.
{
    int i;

    if (*w != NULL)//Если текущая вершина не равна NULL
    {
        Vyvod(&((**w).Right), l + 1);//вызываем функцию Vyvod для левого поддерева с уровнем l+1, затем выводим пробелы для выравнивания уровней
        for (i = 1; i <= l; i++) cout << "   ";
        cout << (**w).Key << endl; //выводим значение ключа текущей вершины
        Vyvod(&((**w).Left), l + 1);// переходим к правому поддереву, вызывая функцию Vyvod с уровнем l+1.
    }
}


void TREE::Search(int x, node** p)
//Поиск звена x в бинарном дереве со вставкой
//            (рекурсивный алгоритм).
//*p - указатель на вершину дерева.
{
    if (*p == NULL)// Если вершины нет в дереве, то создать новую вершину с ключом x и счетчиком 1
    { // Вершины в дереве нет; включить ее.
        *p = new(node);
        (**p).Key = x;     (**p).Count = 1;
        (**p).Left = (**p).Right = NULL;
    }
    else// Если вершина уже есть в дереве, то увеличить счетчик
        if (x < (**p).Key) Search(x, &((**p).Left));// Рекурсивный вызов для левого поддерева
        else
            if (x > (**p).Key) Search(x, &((**p).Right));// Рекурсивный вызов для правого поддерева
            else  (**p).Count += 1;// Увеличить счетчик звена x в дереве
}

void TREE::Addition(int k)
// Поиск звена k в бинарном дереве со вставкой
//         (нерекурсивный алгоритм).
// Tree - указатель на вершину дерева.
{
    node* s;// создаем указатель на новую вершину

    Poisk(k); // вызываем функцию поиска и запоминаем результат в B и Res
    if (!B)// если элемент не найден в дереве
    {
        s = new(node);// создаем новую вершину
        (*s).Key = k;    (*s).Count = 1;// заполняем значения в новой вершине
        (*s).Left = (*s).Right = NULL; // делаем новую вершину листом
        if (Tree == NULL) Tree = s;// если дерево пустое, то новая вершина является корнем дерева
        else
            if (k < (*Res).Key) (*Res).Left = s;// если значение новой вершины меньше значения Res, то добавляем ее в левое поддерево
            else  (*Res).Right = s;// если значение новой вершины больше значения Res, то добавляем ее в правое поддерево
    }
    else  (*Res).Count += 1;// если элемент найден в дереве, увеличиваем счетчик в Res
}

int TREE::Poisk(int k)
// Поиск вершины с ключом k в дереве
//      (нерекурсивный алгоритм).
// Tree - указатель на бинарное дерево.
// Res  - указатель на найденную вершину
// или на лист, к которому можно присоединить новую вершину.
{
    node* p, * q;

    B = FALSE;// Инициализация флага найденного элемента
    p = Tree;// Устанавливаем указатель на корень дерева
    if (Tree != NULL)// Если дерево не пустое
        do
        {
            q = p;// Сохраняем адрес предыдущей вершины
            if ((*p).Key == k) B = TRUE;// Если ключ найден - выставляем флаг
            else
            {
                q = p;// Сохраняем адрес предыдущей вершины
                if (k < (*p).Key) p = (*p).Left;// Идём налево
                else  p = (*p).Right;// Идём направо
            }
            Res = q;// Сохраняем адрес найденной вершины или последней посещенной
        } while (!B && p != NULL);// Пока ключ не найден и не дошли до конца дерева

        return B;// Возвращаем флаг найденного элемента
}

node* TREE::Poisk_1(int k, node** p)
// Поиск вершины с ключом k в дереве
//        (рекурсивный алгоритм).
// *p - указатель на корень дерева.
{
    if (*p == NULL) return (NULL);// Вершины с заданным ключом нет в дереве.
    else
        if ((**p).Key == k) return (*p);// Вершина с заданным ключом найдена.
        else
            if (k < (**p).Key) return Poisk_1(k, &((**p).Left));// Рекурсивный вызов для левого поддерева.
            else return Poisk_1(k, &((**p).Right));// Рекурсивный вызов для правого поддерева.
}

void TREE::Delete(node** p, int k)
// Удаление вершины k из бинарного дерева.
// *p - указатель на корень дерева.
{
    node* q;

    if (*p == NULL) cout << "Вершина с заданным ключом не найдена!\n";// если корня нет, выводим сообщение о том, что вершина не найдена
    else
        if (k < (**p).Key) Delete(&((**p).Left), k);// если ключ k меньше ключа текущей вершины, рекурсивно идем влево
        else
            if (k > (**p).Key) Delete(&((**p).Right), k);// если ключ k больше ключа текущей вершины, рекурсивно идем вправо
            else
            {
                q = *p;
                if ((*q).Right == NULL) { *p = (*q).Left; delete q; }// если правое поддерево отсутствует, удаляем текущую вершину и поднимаем левое поддерево на её место
                else
                    if ((*q).Left == NULL) { *p = (*q).Right; delete q; }// если левое поддерево отсутствует, удаляем текущую вершину и поднимаем правое поддерево на её место
                    else  Delete_1(&((*q).Left), &q);// иначе идем в левое поддерево и ищем наименьший элемент, который заменит текущую вершину
            }
}

void TREE::Delete_1(node** r, node** q)
{
    node* s;

    if ((**r).Right == NULL)// Если у текущей вершины нет правого поддерева
    {
        (**q).Key = (**r).Key; // Заменяем ключ и счетчик удаляемой вершины на ключ и счетчик текущей вершины
        (**q).Count = (**r).Count;
        // Удаляем текущую вершину
        *q = *r;
        s = *r; *r = (**r).Left; delete s;// Перемещаем левое поддерево на место удаляемой вершины
    }
    else  Delete_1(&((**r).Right), q);// Иначе продолжаем поиск в правом поддереве
}
