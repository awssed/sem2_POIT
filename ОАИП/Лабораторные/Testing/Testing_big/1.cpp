#include <iostream> // подключение стандартной библиотеки ввода-вывода

using namespace std; // использование пространства имен std

struct node // определение структуры node для узлов дерева
{
    int KeyMin; // Минимальный ключ вершины.
    int KeyMax; // Максимальный ключ вершины.
    node* Left; // Указатель на "левого" сына.
    node* Right; // Указатель на "правого" сына.
};

class TREE // определение класса TREE для бинарного дерева отрезков
{
private:
    node* Tree; //Указатель на корень дерева.
    void Search(int, int, node**); // прототип функции Search для построения дерева
public:
    TREE() { Tree = NULL; } // конструктор по умолчанию
    void BuildTree(); //Построение дерева отрезков.
    node** GetTree() { return &Tree; } //Получение вершины дерева.
    void CleanTree(node**); // функция очистки дерева
    void Vyvod(node**, int); // функция вывода дерева на экран
};

void main() // главная функция программы
{
    setlocale(LC_ALL, "Rus"); // установка русской локали
    TREE A; // создание объекта класса TREE

    A.BuildTree(); // вызов метода BuildTree для построения дерева
    cout << "\nВывод дерева:\n";
    A.Vyvod(A.GetTree(), 0); // вызов метода Vyvod для вывода дерева на экран
    A.CleanTree(A.GetTree()); // вызов метода CleanTree для очистки дерева

    cout << "\n";
    system("PAUSE"); // пауза системы перед выходом из программы
}

void TREE::BuildTree()
// Построение бинарного дерева (рекурсивный алгоритм).
// Tree - указатель на корень дерева.
{
    int k1, k2;

    // Запрос у пользователя границ отрезка.
    cout << "Введите два целых числа...\n";
    cin >> k1;
    cin >> k2;

    // Вызов метода Search для добавления отрезка в дерево.
    Search(k1, k2, &Tree);
}

// Функция построения дерева отрезков на основе указателя на корень дерева и заданных границ отрезка.
// k1 - минимальное значение ключа отрезка.
// k2 - максимальное значение ключа отрезка.
// p - указатель на указатель на корень дерева.
void TREE::Search(int k1, int k2, node** p)
{
    if (k2 - k1 > 1) // Если длина отрезка больше 1, создаем новую вершину дерева.
    {
        *p = new (node); // Выделяем память под новую вершину и присваиваем указатель на нее указателю p.
        (**p).KeyMin = k1; // Задаем минимальный ключ для созданной вершины.
        (**p).KeyMax = k2; // Задаем максимальный ключ для созданной вершины.
        (**p).Left = (**p).Right = NULL; // Указатели на левого и правого потомка пока указывают на NULL.
        Search(k1, (k1 + k2) / 2, &((**p).Left)); // Рекурсивно строим дерево для левого подотрезка.
        Search((k1 + k2) / 2, k2, &((**p).Right)); // Рекурсивно строим дерево для правого подотрезка.
    }
    else // Если длина отрезка равна 1, создаем новую вершину дерева.
    {
        *p = new (node); // Выделяем память под новую вершину и присваиваем указатель на нее указателю p.
        (**p).KeyMin = k1; // Задаем минимальный ключ для созданной вершины.
        (**p).KeyMax = k2; // Задаем максимальный ключ для созданной вершины.
        (**p).Left = (**p).Right = NULL; // Указатели на левого и правого потомка пока указывают на NULL.
    }
}

void TREE::CleanTree(node** w)
// Очистка дерева с помощью рекурсивной функции.
// *w - указатель на корень дерева.
{
    if (*w != NULL) // если дерево не пустое
    {
        CleanTree(&((**w).Left)); // рекурсивный вызов функции для левого поддерева
        CleanTree(&((**w).Right)); // рекурсивный вызов функции для правого поддерева
        delete* w; // удаление текущего узла
}
}
// Функция для вывода дерева на экран
// w - указатель на корень дерева.
// l - уровень дерева для текущего узла.
void TREE::Vyvod(node** w, int l)
//Изображение дерева *w на экране дисплея
//          (рекурсивный алгоритм).
//*w - указатель на корень дерева.
{
    int i;
    // Если дерево не пустое, продолжаем рекурсивный обход
    if (*w != NULL)
    {
        // Рекурсивный вызов функции для вывода правого поддерева
        Vyvod(&((**w).Right), l + 1);
        // Выводим пробелы для выравнивания уровней 
        for (i = 1; i <= l; i++) cout << "   ";
        // Выводим значения минимального и максимального ключа у текущего узла
        cout << (**w).KeyMin << ", " << (**w).KeyMax << endl;
        // Рекурсивный вызов функции для вывода левого поддерева
        Vyvod(&((**w).Left), l + 1);
    }
}
