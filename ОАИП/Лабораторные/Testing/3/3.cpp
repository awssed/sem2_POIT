// Подключение необходимых библиотек
#include <iostream>
using namespace std;

// Описание структуры узла дерева
struct node
{
    int Key; // Ключ узла
    int Count; // Счетчик для хранения количества узлов в дереве
    node* Left; // Указатель на левое поддерево
    node* Right; // Указатель на правое поддерево
};

// Описание класса дерева
class TREE
{
private:
    node* Tree; // Указатель на корень дерева
    void Search(int, node**); // Поиск вершины с ключом int в дереве со вставкой
public:
    TREE() { Tree = NULL; } // Конструктор по умолчанию, инициализирующий корень дерева пустым значением
    node** GetTree() { return &Tree; } // Получение вершины дерева
    void BuildTree(); // Построение дерева
    void CleanTree(node**); // Очистка дерева
    void ObhodEnd(node**); // Концевой обход дерева
    void ObhodLeft(node**); // Левосторонний обход дерева
    void ObhodBack(node**); // Обратный обход дерева
    void Vyvod(node**, int); // Изображение дерева на экране дисплея
    int Height(node**); // Определение высоты бинарного дерева
};

// Определение функции main()
void main()
{
    // Установка локали (региональных настроек) на русский язык
    setlocale(LC_ALL, "Rus");
    // Создание объекта класса TREE
    TREE A;

    // Построение дерева
    A.BuildTree();

    // Вывод дерева на экран
    cout << "\nВывод дерева:\n";
    A.Vyvod(A.GetTree(), 0);

    // Определение высоты дерева и вывод на экран
    cout << "\nВысота дерева:" << A.Height(A.GetTree()) << endl;

    // Левосторонний обход дерева и вывод на экран
    cout << "\nЛевосторонний обход дерева: ";
    A.ObhodLeft(A.GetTree());

    // Концевой обход дерева и вывод на экран
    cout << "\nКонцевой обход дерева: "; A.ObhodEnd(A.GetTree());

    // Обратный обход дерева и вывод на экран
    cout << "\nОбратный обход дерева: "; A.ObhodBack(A.GetTree());

    // Очистка дерева
    A.CleanTree(A.GetTree());

    // Ожидание ввода пользователя для завершения программы
    cout << "\n";
    system("PAUSE");
}
// Метод BuildTree класса TREE для построения бинарного дерева.
// Используется рекурсивный алгоритм. Tree - указатель на корень дерева.
void TREE::BuildTree()
// Построение бинарного дерева (рекурсивный алгоритм).
// Tree - указатель на корень дерева.
{
    int el;//объявление переменной el, которая будет использоваться для ввода ключей вершин дерева

    cout << "Вводите ключи вершин дерева ...\n";
    cin >> el;//чтение значения переменной el из стандартного ввода
    while (el != 0)// цикл, который будет выполняться до тех пор, пока пользователь не введет 0
    {
        Search(el, &Tree); cin >> el;//ызов функции Search, которая вставляет новую вершину с заданным ключом в дерево, и затем считывает следующий ключ из стандартного ввода.
    }
}

void TREE::Search(int x, node** p)
//  Поиск вершины с ключом x в дереве со вставкой
//             (рекурсивный алгоритм).
// *p - указатель на корень дерева.
{
    if (*p == NULL)//Если вершины с таким ключом в дереве нет, вставить новую вершину
    {// Вершины в дереве нет; включить ее.
        *p = new(node);//выделение памяти
        //оздание новой вершины и инициализация ее полей
        (**p).Key = x;     (**p).Count = 1;
        (**p).Left = NULL; (**p).Right = NULL;
    }
    else//Если вершина с таким ключом уже существует, увеличить счетчик встречаемости этого ключа в текущей вершине или продолжить поиск в левом или правом поддереве в зависимости от значения ключа
        if (x < (**p).Key) Search(x, &((**p).Left));
        else
            if (x > (**p).Key) Search(x, &((**p).Right));
            else  (**p).Count = (**p).Count + 1;
}
// Левосторонний обход дерева - обходит вершины дерева, начиная с левого поддерева и заканчивая правым поддеревом.
void TREE::ObhodLeft(node** w)
//Левосторонний обход дерева.
//*w - указатель на корень дерева.
{
    if (*w != NULL) // Если указатель на корень дерева не пустой
    {
        cout << (**w).Key << " "; // Выводим ключ вершины
        ObhodLeft(&((**w).Left)); // Рекурсивно обходим левое поддерево
        ObhodLeft(&((**w).Right)); // Рекурсивно обходим правое поддерево
    }
}
// Этот метод производит концевой обход бинарного дерева, начиная с корня, переданного по указателю в качестве аргумента.
void TREE::ObhodEnd(node** w)
//Концевой обход дерева.
//*w - указатель на корень дерева.
{
    if (*w != NULL)// Если указатель на корень дерева не пустой:
    {
        ObhodEnd(&((**w).Left));// Рекурсивно вызываем функцию ObhodEnd для левого и правого поддеревьев корня.
        ObhodEnd(&((**w).Right));// Рекурсивно вызываем функцию ObhodEnd для левого и правого поддеревьев корня
        cout << (**w).Key << " ";//// Выводим значение ключа корня.
    }
}

void TREE::ObhodBack(node** w)
//Обратный обход дерева.
//*w - указатель на корень дерева.
//Если указатель *w не является пустым, производится обратный обход левого поддерева, затем выводится ключ текущей вершины и производится обратный обход правого поддерева.
{
    if (*w != NULL)
    {
        ObhodBack(&((**w).Left));//рекурсивный вызов на левое поддерево
        cout << (**w).Key << " ";//вывод ключа
        ObhodBack(&((**w).Right));//рекурсивный вызов на правое поддерево
    }
}

void TREE::CleanTree(node** w)
//Очистка дерева.
//*w - указатель на корень дерева.
//указатель на корень дерева (*w) используется для перебора всех вершин дерева. Если текущая вершина не является конечной (не равна NULL), то мы рекурсивно вызываем метод CleanTree для левого и правого поддеревьев этой вершины. Затем мы удаляем текущую вершину.
{
    if (*w != NULL)
    {
        CleanTree(&((**w).Left));  // Рекурсивно очищаем левое поддерево.
        CleanTree(&((**w).Right)); // Рекурсивно очищаем правое поддерево.
        delete* w;                 // Удаляем текущую вершину.
    }
}

void TREE::Vyvod(node** w, int l)
//Изображение дерева *w на экране дисплея
//          (рекурсивный алгоритм).
//*w - указатель на корень дерева.
{
    int i;

    if (*w != NULL)// проверка, что указатель на корень дерева не является NULL
    {
        Vyvod(&((**w).Right), l + 1);//рекурсивный вызов функции для правого поддерева с передачей указателя на указатель на корень правого поддерева и увеличением отступа на 1.
        for (i = 1; i <= l; i++) cout << "   ";//// выводим отступы перед вершиной
        cout << (**w).Key << endl;// выводим значение вершины
        Vyvod(&((**w).Left), l + 1);// рекурсивный вызов функции для левого поддерева с передачей указателя на указатель на корень левого поддерева и увеличением отступа на 1.
    }
}

int TREE::Height(node** w)
//Определение высоты бинарного дерева.
//*w - указатель на корень дерева.
{
    int h1, h2;//Объявление двух переменных для хранения высоты левого и правого поддеревьев
    if (*w == NULL) return (-1);//Если указатель на узел равен NULL, то высота дерева равна -1, так как узлов не существует
    else
    {
        h1 = Height(&((**w).Left));//Рекурсивно вычисляем высоту левого поддерева
        h2 = Height(&((**w).Right));//Рекурсивно вычисляем высоту правого поддерева
        if (h1 > h2) return (1 + h1);//Если высота левого поддерева больше высоты правого, то высота дерева равна 1 + высоте левого поддерева.
        else  return (1 + h2);//Или высота дерева равна 1 + высоте правого поддерева
    }
}
