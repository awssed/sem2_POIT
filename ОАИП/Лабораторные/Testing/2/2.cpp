#include <iostream>
using namespace std;

// Описание структуры для вершин дерева отрезков.
struct node
{
    int KeyMin; // Минимальный ключ вершины.
    int KeyMax; // Максимальный ключ вершины.
    node* Left; // Указатель на "левого" сына.
    node* Right; // Указатель на "правого" сына.
};

// Описание класса дерева отрезков.
class TREE
{
private:
    node* Tree; // Указатель на корень дерева.
    int S; // Количество вхождений заданной точки в дерево.
    void Search(int, int, node**); // Поиск заданной точки в дереве.
public:
    TREE() { Tree = NULL; S = 0; } // Конструктор класса.
    void BuildTree(); // Построение дерева отрезков.
    node** GetTree() { return &Tree; } // Получение вершины дерева.
    void CleanTree(node**); // Очистка дерева.
    void Vyvod(node**, int); // Вывод дерева на экран.
    int GetCount() { return S; } // Получение количества вхождений заданной точки в дерево.
    void Count(node**, float); // Подсчет количества точек на отрезке.
};

void main()
{
    // Установка русской локали для вывода на кириллице.
    setlocale(LC_ALL, "Rus");

    // Создание объекта класса дерева отрезков.
    TREE A;

    float X;

    // Построение дерева отрезков с помощью метода BuildTree класса TREE.
    A.BuildTree();

    // Вывод дерева на экран.
    cout << "\nВывод дерева:\n";
    A.Vyvod(A.GetTree(), 0);

    // Запрос у пользователя абсциссы точки.
    cout << "\nВведите абсциссу точки: ";
    cin >> X;

    // Подсчет количества интервалов, содержащих заданную точку.
    A.Count(A.GetTree(), X);

    // Вывод результата подсчета на экран.
    cout << "Точка принадлежит " << A.GetCount() << " интервалам";

    // Очистка дерева отрезков.
    A.CleanTree(A.GetTree());

    // Завершение программы.
    cout << "\n";
    system("PAUSE");
}

void TREE::BuildTree()
// Построение бинарного дерева (рекурсивный алгоритм).
// Tree - указатель на корень дерева.
{
    int k1, k2;

    // Запрос у пользователя границ отрезка.
    cout << "Введите два целых числа...\n";
    cin >> k1;
    cin >> k2;

    // Вызов метода Search для добавления отрезка в дерево.
    Search(k1, k2, &Tree);
}

// Функция построения дерева отрезков на основе указателя на корень дерева и заданных границ отрезка.
// k1 - минимальное значение ключа отрезка.
// k2 - максимальное значение ключа отрезка.
// p - указатель на указатель на корень дерева.
void TREE::Search(int k1, int k2, node** p)
{
    if (k2 - k1 > 1) // Если длина отрезка больше 1, создаем новую вершину дерева.
    {
        *p = new (node); // Выделяем память под новую вершину и присваиваем указатель на нее указателю p.
        (**p).KeyMin = k1; // Задаем минимальный ключ для созданной вершины.
        (**p).KeyMax = k2; // Задаем максимальный ключ для созданной вершины.
        (**p).Left = (**p).Right = NULL; // Указатели на левого и правого потомка пока указывают на NULL.
        Search(k1, (k1 + k2) / 2, &((**p).Left)); // Рекурсивно строим дерево для левого подотрезка.
        Search((k1 + k2) / 2, k2, &((**p).Right)); // Рекурсивно строим дерево для правого подотрезка.
    }
    else // Если длина отрезка равна 1, создаем новую вершину дерева.
    {
        *p = new (node); // Выделяем память под новую вершину и присваиваем указатель на нее указателю p.
        (**p).KeyMin = k1; // Задаем минимальный ключ для созданной вершины.
        (**p).KeyMax = k2; // Задаем максимальный ключ для созданной вершины.
        (**p).Left = (**p).Right = NULL; // Указатели на левого и правого потомка пока указывают на NULL.
    }
}

// Подсчет количества интеpвалов деpева p,
// содеpжащих точку X.
void TREE::Count(node** p, float X)
{
    // Проверяем, что указатель не пустой
    if (*p != NULL)
    {
        // Рекурсивно вызываем функцию для правого поддерева
        Count(&((**p).Right), X);
        // Если точка X находится в пределах интервала, увеличиваем счетчик S на 1
        if (X >= (**p).KeyMin && X <= (**p).KeyMax)  S++;

        // Рекурсивно вызываем функцию для левого поддерева
        Count(&((**p).Left), X);
    }
}

void TREE::CleanTree(node** w)
// Очистка дерева с помощью рекурсивной функции.
// *w - указатель на корень дерева.
{
    if (*w != NULL) // если дерево не пустое
    {
        CleanTree(&((**w).Left)); // рекурсивный вызов функции для левого поддерева
        CleanTree(&((**w).Right)); // рекурсивный вызов функции для правого поддерева
        delete* w; // удаление текущего узла
    }
}
// Функция для вывода дерева на экран
// w - указатель на корень дерева.
// l - уровень дерева для текущего узла.
void TREE::Vyvod(node** w, int l)
//Изображение дерева *w на экране дисплея
//          (рекурсивный алгоритм).
//*w - указатель на корень дерева.
{
    int i;
    // Если дерево не пустое, продолжаем рекурсивный обход
    if (*w != NULL)
    {
        // Рекурсивный вызов функции для вывода правого поддерева
        Vyvod(&((**w).Right), l + 1);
        // Выводим пробелы для выравнивания уровней
        for (i = 1; i <= l; i++) cout << "   ";
        // Выводим значения минимального и максимального ключа у текущего узла
        cout << (**w).KeyMin << ", " << (**w).KeyMax << endl;
        // Рекурсивный вызов функции для вывода левого поддерева
        Vyvod(&((**w).Left), l + 1);
    }
}
