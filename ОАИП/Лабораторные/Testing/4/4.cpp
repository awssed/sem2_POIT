#include <iostream>
using namespace std;

// Структура узла дерева
struct node
{
    int Key; // Информационное поле
    int Count; // Счетчик количества вхождений элемента в дерево
    node* Left; // Указатель на левого потомка
    node* Right; // Указатель на правого потомка
};

struct no // Звено стека
{
    node* elem; // Информационное поле.
    int ch; // Уровень вершины.
    no* sled; // Указатель на вершину.
};
    
class TREE
{
private:
    node* Tree;
    void PushStack(no**, node**, int*);// Помещение звена с элементами *el и n в
    // стек. *stk - указатель на стек.
    void PopStack(no**, node**, int*); // Извлечение из стека звена
    // с элементами *t и n.
    // *stk - указатель на стек
    void VyvodStack(no**); // Вывод содержимого стека на экран дисплея.
    // *stk - указатель на стек.

public:
    TREE() { Tree = new(node); (*Tree).Right = NULL; }
    node* GetTreeRight() { return (*Tree).Right; }
    void  TreeSearch(int); // Поиск вершины с информационным полем  el в дереве с
    // последующим (в случае неудачного поиска!) включением
    // в дерево. Tree - указатель на корень дерева.

    void  VyvodTree(node*); //Построение дерева, заданного указателем t,
    //на экране дисплея (нерекурсивный алгоритм).

};

// Главная функция программы
void main()
{
    setlocale(LC_ALL, "Rus"); // Установка локали для вывода русских символов на консоль
    TREE A; // Создание объекта класса TREE
    int el; // Переменная для ввода информационных полей вершин дерева

    // Ввод значений информационных полей вершин
    cout << "Вводите значения информационных полей вершин: " << endl;
    cin >> el;
    while (el != 0)
    {
        A.TreeSearch(el); // Поиск вершины с информационным полем el в дереве
        cin >> el; // Ввод нового значения информационного поля
    }

    // Построение дерева на экране дисплея
    A.VyvodTree(A.GetTreeRight());

    cout << "\n";
}

void TREE::TreeSearch(int el)
// Поиск вершины с информационным полем  el в дереве с
// последующим (в случае неудачного поиска!) включением
// в дерево. Tree - указатель на корень дерева.
{
    node* p1, * p2;// Указатели на текущую вершину и ее родителя.
    int  d; // Результат сравнения ключа текущей вершины с искомым ключом.

    p2 = Tree; // Устанавливаем родительскую вершину на корень дерева.
    p1 = (*p2).Right;// Устанавливаем указатель на текущую вершину на правое поддерево корня.
    d = 1;//// d принимает значение 1
    // Пока указатель p1 не указывает на конец дерева и значение d не равно 0
    while (p1 != NULL && d != 0)
    {
        p2 = p1;// Указатель p2 устанавливается на p1.
        if (el < (*p1).Key) { p1 = (*p1).Left; d = -1; }// Если el меньше ключа текущей вершины, переходим на левую ветвь и присваиваем d значение -1.
        else
            if (el > (*p1).Key) { p1 = (*p1).Right; d = 1; }// Если el больше ключа текущей вершины, переходим на правую ветвь и присваиваем d значение 1.
            else  d = 0;// Иначе ключ текущей вершины равен el, присваиваем d значение 0.
    }
    if (d == 0)  (*p1).Count = (*p1).Count + 1;// Если найдена вершина с ключом el
    else
    {
        p1 = new(node);// Создаем новую вершину.
        (*p1).Key = el;  (*p1).Left = NULL;
        (*p1).Right = NULL;  (*p1).Count = 1;
        if (d < 0) (*p2).Left = p1;// Если d меньше 0, присваиваем указатель на новую вершину левой ветви p2.
        else  (*p2).Right = p1;// Иначе присваиваем указатель на новую вершину правой ветви p2.
    }
}


void TREE::VyvodTree(node* t)
//Построение дерева, заданного указателем t,
//на экране дисплея (нерекурсивный алгоритм).
{
    no* stk, * stk1;// Объявление указателей на стеки для узлов дерева
    node* u;// Объявление указателя на узел дерева
    int i, n;// Объявление переменных для хранения индексов и количества пробелов
    stk = stk1 = NULL; // Инициализация указателей на стеки и количества пробелов
    n = 0;
    while (t != NULL)// Пока указатель на текущий узел не равен NULL
    {
        PushStack(&stk1, &t, &n);// Добавляем указатель на текущий узел во вспомогательный стек
        if ((*t).Right != NULL)// Если у узла есть правый потомок
        {
            if ((*t).Left != NULL) PushStack(&stk, &((*t).Left), &n);//// Если у узла есть левый потомок, добавляем его в основной стек
            t = (*t).Right;// Переходим к правому потомку
        }
        else
        {
            if ((*t).Left != NULL)// Если у узла есть левый потомок
            {
                if (stk1 != NULL)// Если вспомогательный стек не пустой
                {
                    PopStack(&stk1, &u, &n);// Извлекаем из вспомогательного стека указатель на родительский узел и его глубину
                    for (i = 0; i <= n; i++) cout << " ";// Выводим пробелы перед значением узла
                    cout << (*u).Key << endl;// Выводим значение узла на экран
                }
                t = (*t).Left;// Переходим к левому потомку
            }
            else
                if (stk == NULL) t = NULL;// Если основной стек пуст, выходим из цикла
                else
                {
                    while ((*stk).elem != (*((*stk1).elem)).Left)// Пока в основном стеке не найден узел-родитель для текущего узла
                    {
                        PopStack(&stk1, &u, &n);// Извлекаем из вспомогательного стека указатель на родительский узел и его глубину
                        for (i = 0; i <= n; i++) cout << " ";// Выводим пробелы перед значением узла
                        cout << (*u).Key << endl;// Выводим значение узла на экран
                    }
                    PopStack(&stk1, &u, &n);// Извлекаем из вспомогательного стека
                    for (i = 0; i <= n; i++) cout << " ";// Выводим пробелы перед значением узла
                    cout << (*u).Key << endl;// Выводим значение узла на экран
                    PopStack(&stk, &t, &n);//извлукаем из стека
                }
        }
        n = n + 1;//увеличиваем n на 1
    }
    VyvodStack(&stk1);//вывод
}


void TREE::PushStack(no** stk, node** el, int* n)
// Помещение звена с элементами *el и n в стек.
// *stk - указатель на стек.
{
    no* q;

    q = new(no);// Выделение памяти под новый элемент стека.
    (*q).elem = *el;  // Присваивание указателю на звено переданный указатель на элемент.
    (*q).ch = *n;// Присваивание указателю на число ch в структуре no переданное значение n
    (*q).sled = *stk; // Присваивание указателю на следующий элемент стека указатель на текущий верхний элемент стека.
    *stk = q;// Указатель на верхний элемент стека указывает на новый элемент.
}

void TREE::PopStack(no** stk, node** t, int* n)
// Извлечение из стека звена с элементами *t и n.
// *stk - указатель на стек.
{
    no* q;

    if (*stk != NULL)// Если стек не пустой, извлекаем верхнее звено
    { // Присваиваем элемент t и значение n элементу верхнего звена
        *t = (**stk).elem;
        *n = (**stk).ch;
        q = *stk;
        *stk = (**stk).sled;
        delete q;// Удаляем верхнее звено
    }
}

void TREE::VyvodStack(no** stk)
// Вывод содержимого стека на экран дисплея.
// *stk - указатель на стек.
{
    node* k;
    int i, n;
    // Пока стек не пуст
    while (*stk != NULL)
    {
        k = (**stk).elem;// Сохранение элемента из верхушки стека
        n = (**stk).ch;// Сохранение количества пробелов, необходимых для форматирования вывода
        for (i = 0; i <= n; i++) cout << " ";// Вывод пробелов перед элементом
        cout << (*k).Key << endl;// Вывод ключа элемента на экран
        *stk = (**stk).sled;// Переход к следующему элементу стека
    }
}