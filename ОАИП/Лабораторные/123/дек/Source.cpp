#include<iostream>
using namespace std;

struct node//Структура элемента дека потсроенного но основе односвязного списка
{
    int elem;//Информационное поле
    node* sled;//Указатель нас следующий элемент дека
};
class Spisok//
{
private:
    node* ld, * rd;//Указатель правый и левый конец дека
    int el_left, el_right;//Объвления перменных для хранения и работы с извлеченный првых и левых звеньев
public:
    void POSTROENIE();//Функция построения дека
    void VYVOD();//Функция вывода всего дека
    void VSTAV1(int);//Функция добавления звена спрва
    void VSTAV2(int);//Функция добавления звена слева
    int SetElLeft() { return el_left; }// Функия возвращающая извлеченный звена слева для дальнейшей работы с ним
    int SetElRight() { return el_right; }// Функия возвращающая извлеченный звена спрва для дальнейшей работы с ним
    void YDALE1();//Функция удаления звена спрва
    void YDALE2();//Функция удаления звена слева
    void OCHISTKA();//Функция полной очистки дека
};

void main()
{
    setlocale(LC_ALL, "Rus");
    Spisok A;//Объявление дека типа spisok который был определён выше
    int el;//Объявление буферной переменной для вставки звена в дек

    A.POSTROENIE(); A.VYVOD();//Вфзов функции построения всего дека и его полный вывод
    cout << "Добавим звено справа.\n";
    cout << "Введите элемент добавляемого звена: ";
    cin >> el;//Инициализация буферной переменной для добавления в правый край дека
    A.VSTAV1(el); A.VYVOD();//Вызов функции вставки в правый край дека и печать всего дека
    cout << "Добавим звено слева.\n";
    cout << "Введите элемент добавляемого звена: ";
    cin >> el;//Инициализация буферной перменной для вствки звена слева
    A.VSTAV2(el); A.VYVOD();//Вызов функции вствки слева и печать всего дека
    cout << "Удалим звено справа.\n";
    A.YDALE1(); A.VYVOD(); //Вызов функции удаления прваго звена и печать всего дека
    cout << A.SetElRight() << endl;//Вывод извлеченного правого звена
    cout << "Удалим зввено слева.\n";
    A.YDALE2(); A.VYVOD();//Вызов функции удаления звена слева и вывод всего дека
    cout << A.SetElLeft() << endl;//Вывод извлеченного слевого звена
    A.OCHISTKA();//Понгая очистка дека

    cout << "\n";
    system("PAUSE");
}

void Spisok::POSTROENIE()
//Построение дека :
// ld - указатель на левый конец дека,
// rd - Указатель на правый конец дека.
{
    node* k;//Объявление указателя на звено дека
    int el;//Буферной перемнной для вставки в информационное поле дека

    cout << "Вводите содержимое звеньев дека: \n";
    cin >> el;//Инициализация буферной переменной
    if (el != 0)//Пока не будет введен ноль будем заполнять дек
    {
        k = new (node);//Выделение памяти для нового звена дека
        (*k).elem = el;//Заолнение информационного поля звена
        (*k).sled = NULL;//Указатель первого введённого звена будет указавать на ноль, т.к перед ним нету других звеньев
        ld = k;rd = k;//Указатель на левый и правый край дека будет пока что направлен на самый первый введённый элемент дека, т.к он единственный
        cin >> el;//Ввод нового значения новго звена
        while (el != 0)//Пока введенный элемент не будет равне нулю будем вставлять звенья в правый конец дека
        {
            VSTAV1(el); cin >> el;//Вставка элементов в правый конец дека
        }
    }
    else
    {
        rd = NULL; ld = NULL;//Если первый введенный элемент дека будет равен нулю то переводим правый и левый указатели на ноль
    }
}

void Spisok::VYVOD()
//Вывод содержимого дека:
// ld - указатель на левый конец дека.
{
    node* k;//Объявлние звена дека в который будем поочредно записывать каждое звено дека и выводить его

    k = ld; //Переводим указатель k на левый конец дека
    cout << "Дек: ";
    while (k != NULL)//Пока не достичнем нулевого элемента будем выводь звенья дека
    {
        cout << (*k).elem << " "; //Печать информационного поля звена дека
        k = (*k).sled;//Перевод указателя k на следующий элемент дека
    }
    cout << endl;
}

void Spisok::VSTAV1(int el)
// Помещение звена, содержащего элемент el, в дек справа.
// ld - указатель на левый конец дека,
// rd - указатель на правый конец дека.
{
    node* k;//Объявление новго звена которое предстоит вставить правый край дека

    k = new (node);//Выделение памяти для нового звена
    (*k).elem = el; //Заполнение поля дека
    (*k).sled = NULL;//Присваивание указателю на следующий элемент ноаого звена нуль ,т.к он будет самый правый будет считаться самым последним в односвязном списке 
    if (rd != NULL)//Если правый указатель не равен нулю
    {
        (*rd).sled = k; //перенаправляем правый указатель на новый вставляемый элемент
        rd = k;// пренапрявляем основной правый указатель на последнее правое вставленное звено
    }
    else//В другом случае вставленный элемент в деке будет считаться единственным
    {
        rd = k; ld = k;//Указатель на левый и правый край дека будет пока что направлен на самый первый введённый элемент дека, т.к он единственный
    }
}

void Spisok::VSTAV2(int el)
//Помещение звена, содержащего элемент el, в дек слева.
// ld - указатель на левый конец дека,
// rd - указатель на правый конец дека.
{
    node* k;//Объявление новго левого звена

    k = new (node);//Выделение памяти для нового левого звена
    (*k).elem = el; //Заполнение информационного поля нового звена
    (*k).sled = ld;//Напрявляем указатель нового свена следующий за ним
    if (ld != NULL) ld = k;//Если это не первый указатель на переприсваиваем основное левый указатель на новый левый вставленный элемент
    else { ld = k; rd = k; }////Указатель на левый и правый край дека будет пока что направлен на самый первый введённый элемент дека, т.к он единственный
}

void Spisok::YDALE1()
//Удаление звена из дека справа
//с сохранением удаляемого звена в переменной el_right.
// ld - указатель на левый конец дека,
// rd - указатель на правый конец дека.
{
    node* z;//Объвление указателя на текущее звено
    node* k;//Обявление указателя опережающий текущий на одно звено

    if (rd == ld)//Если у нас одно звено то указатели на левый и првый концы дека будут равны
    {
        el_right = (*rd).elem; //сохранение удаляемого звена в переменной el_right.
        delete rd;//Удаление из памяти звена
        ld = rd = NULL; //Присваивание указателям на правый и левый конец дека нуль
        cout << "Дек пуст!\n";
    }
    else//Если у нас дек имеет больше одного звена
    {
        z = ld; //Инициализация указателя на текущий элемент
        k = (*ld).sled;//Инициализация опрежающего указателя
        while (k != rd)//Пока поережащий указатель не достигнет прового конца
        {
            z = k; //текущий указатель не перещаем следующее звено
            k = (*k).sled;//опрежающий казатель премещаем на следующее звено
        }
        el_right = (*rd).elem; //сохранение удаляемого звена в переменной el_right.
        (*z).sled = NULL; //Устанавливаем указатель нас следующий жлемент текущего звена на нуль, т.к он теперь последний
        delete rd;//Освождаем память уадляемого звена
        rd = z;//Перемащаем казатель на правый конец не предыдущее звено
    }
}

void Spisok::YDALE2()
// Удаление звена из дека слева
// с сохранением удаляемого звена в переменной el_left.
// ld - указатель на левый конец дека,
// rd - указатель на правый конец дека.
{
    node* q;//Объвление указателя на текущее звено в деке

    if (ld != NULL)//Если дек не пустой
    {
        el_left = (*ld).elem;//сохранение удаляемого звена в переменной el_left.
        q = ld;//Ставим текущий указатель на левый конец дека
        ld = (*ld).sled; //Перемещаем указатель на левый конец на дека на следующее звено
        delete q;//Освождаем память занимаоемое удаляемым левым звеном
    }
    else  cout << "Дек пуст!\n";
}

void Spisok::OCHISTKA()
{
    node* k, * q;//Объявление текущего и опережающего на одно звено указателя

    k = ld;//Текущий указатель будет равен указтелю на самое левое звено
    if (k != NULL)//Пока не достичнем нудевого звена
    {
        q = (*k).sled;//Устанавливаем на следующее за k звено опрежащий указатель
        while (q != NULL)//пока опреежающий указатель не достигнет нуля
        {
            delete k;//Освобждение памяти звена на которое указывает текущий указатель
            k = q; //Перемещение текущего указтеля на следующее звено
            q = (*k).sled;//Перемещение опрежающего указателя на следующее звено
        }
        delete k;//Освождение памяти занимаемое самым последним оставшимся звеном
    }
}
