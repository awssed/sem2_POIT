#include<iostream>
using namespace std;

struct node // Объявление стурктуры элементов из которых будет сосстоять наш список и впоследствии котрого будет реализвовываться наш стек
{
    int elem;// Информационная часть элемента списка
    node* sled;// Указатель на следующий элемент списка
};
class Spisok // Класс в котором будут обявлены прототипы функций для работы с нашим стеком и указатель на сам стек
{
private:
    //Cвойства класса:стек построенный на основе односвязного списка и переменная в которой будет содержатся последний извлеченный элемент из стека
    node* stk;
    int klad;
public:
    //Функции(методы) нашего класса с помощью которых мы бедем работать со стеком
    Spisok() { stk = NULL; }
    int Set_Stack() { return klad; }//Функция возвращающая извлеченный элемент для дальнейшей работы с ним
    void POSTROENIE();//Функция с помощью которой будет строиться и сначала заполняться стек 
    void VYVOD();// Вывод всего стека
    void W_S(int);// Функция вставки элемента в стек
    void YDALENIE();// Функция удаление элемента из стека по принципу LIFO
    void OCHISTKA();//Функция полной очистки стека
};

void main()
{
    setlocale(LC_ALL, "Rus");
    Spisok A;//Объявление начала списка
    int  el;// Оюъявление буферной переменной для заполнение информацие и последующей её передачи функции вставки в стек
    int t; //Содержимое информационного поля верхушки стека.

    A.POSTROENIE(); A.VYVOD();// Строим стек и выводим все его элементы
    cout << "Введите вставляемый элемент: ";
    cin >> el;//Инициализация бкфкрной пременной для последуещей вставки
    A.W_S(el); A.VYVOD();//Вставка элемента в верхущку стека и вывод всего стека

    cout << "Удалим элемент из стека.\n";
    A.YDALENIE();//Удаление последнего элемента
    t = A.Set_Stack();//Извление посследнего элемента стека
    cout << "Из стека было извлечено число... " << t << endl;//
    A.VYVOD();//Вывод всего стека
    A.OCHISTKA();//Удаление стека

    cout << "\n";
    system("PAUSE");
}

void Spisok::POSTROENIE()
//Построение стека, заданного указателем stk.
{
    node* t;//Объявление элемента списка для последующего создания стека на основе спика
    int el;//Буферная пременная для заполнения информационного поля элемента стека

    cout << "Вводите элементы стека: ";
    cin >> el;//Инициализация бйферной перенной
    while (el != 0)//Пока мы не введём ноль мы будем заполнять стек
    {
        t = new (node);//выделения памяти для каждого элемента стека
        (*t).elem = el; //Заполнения информационного поля элемента стека на основе однозвязног спика
        (*t).sled = stk;//Настройка указателя путем задания его на предудущий элемент
        stk = t; //Перевод нашего head указателя на последнйи введенный элемент стека
        cin >> el;//Ввод новой информации для записи в стек
    }
}

void Spisok::VYVOD()
//Вывод содержимого стека, заданного указателем stk.
{
    node* t;//Объявление указтеля на звено стека и последующего его вывода

    cout << "Содержимое стека: "; t = stk;
    while (t != NULL)//Пока не будет достигнут последнйи элемент стека, указатель на следующий элемент котрого будет равен нулю
    {
        cout << (*t).elem << " ";//Вывод информационного поля
        t = (*t).sled;//Переход на следующий элемент путем присваивание указателю t адреса следующего элемента
    }
    cout << endl;
}

void Spisok::W_S(int el)
//Помещение элемента el в стек stk.
{
    node* q;//Объявление указтеля на звено стека

    q = new (node);//Выделения памяти для вствляемого элемента в стек
    (*q).elem = el; //Заполнения информационного поля
    (*q).sled = stk;//Настройка указателя путем задания его на предудущий элемент
    stk = q;//Перевод нашего head указателя на последнйи введенный элемент стека
}

void Spisok::YDALENIE()
//Удаление элемента из стека, заданного указателем stk.
//Значение информационного поля удаляемого элемента
//помещается в параметр klad.
{
    node* q;//Объявление указтеля на удаляемое звено

    if (stk == NULL)//В случае пустого стека указателя на стек будет равен нулю
        cout << "Стек пуст!\n";
    else
    {
        klad = (*stk).elem; //Сохраниям значение информационного поля удаляемого элемента в переменную клад для дальнейшего использования
        q = stk;//Присваиваем указатель q на удаляемый элемент стека путем присваивания q значение stk, т.к он уже указывает на последний элемент
        stk = (*stk).sled;//Перенастриваем указатель stk на следующий за удаляемым элементом
        delete q;//Освождение памяти удаляемого элемента
    }
}

void Spisok::OCHISTKA()
//Возврат выделенной памяти в "кучу".
{
    node* t, * q;//Объявление указателя на последний вышедший элемент стека и на следующий элемент за ним

    t = stk;//Присваиванеи указтеля на последний вошедший элемнт стека
    if (t != NULL)//Пока не достигнем нулевого элемента стека(последнего элемента) будем их удалять
    {
        q = (*t).sled;//Присваивание q адрес на следующий за последним вошедшим элементом в стек
        while (q != NULL)//Пока опережающий указатель не будет равен нулю будем удалять предыдущие
        {
            delete t; //Освождения памяти занимаемое элементом, на который указывает текущий указатель t
            t = q;//Перемещение текущего указателя на следующий путем присваивание значение опрежающего указателя
            q = (*q).sled;//Перемещение опрежающего указателя на следующий элемент
        }
        delete t;//Освождение памяти занимаемым самым последним элементом стека
    }
}
