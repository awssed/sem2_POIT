
#include <iostream>
using namespace std;

struct node//структура звена кольцевого двунаправленного списка
{
    int elem;//Информационное поле
    node* sled;//Указатель на следующее звено
    node* pred;//Указатель на предыдущее звено 
};

class Spisok //Класс содержащий функции(методы) и переменные для работы с колльцевым двусвязным списком
{
private:
    node* nsp;//указатель на заглавное звено
public:
    Spisok() { nsp = NULL; }//заглавное звено с начала равно нулю т.к спсиок сначала нужно построить
    void BuiltRing(); //Построение двунаправленного кольцевого списка nsp с удаленным заглавным звеном.*nsp - указатель на заглавное звено списка
    void VyvodLeftRight();// Вывод содержимого двунаправленного кольцевого спискас удаленным заглавным звеном "по часовой стрелке".*nsp - указатель на заглавное звено списка.
    void VyvodRightLeft();// Вывод содержимого двунаправленного кольцевого списка с удаленным заглавным звеном "против часовой стрелки".nsp - указатель на заглавное звено списка.
    void InsAfter(node*, int);// Вставление в кольцевой двунаправленный список звенас информационным полем el после  звена, на  которое указывает ссылка Res.
    void InsBefore(node*, int);// Вставка в кольцевой двунаправленный список звена с информационным полем el перед звеном, на  которое указывает ссылка Res. nsp - указатель на заглавное звено списка.
    void Delete(node*);// Удаление из кольцевого двунаправленного списка звена, на которое указывает ссылка Res.nsp - указатель на заглавное звено списка.
    void DelAfter(node*);//Удаление из кольцевого двунаправленного списка звена,расположенного  после  звена, на  которое  указываетссылка Res.nsp - указатель на заглавное звено списка.
    node* SearchRing(int); //Поиск элемента el в кольцевом двунаправленном списке с удаленным заглавным звеном.nsp - указатель на заглавное звено списка.
    void Ochistka();//Полное удаление списка
};

void main()
{
    setlocale(LC_ALL, "Rus");
    Spisok A;//Объявление кольцевого списка
    node* Res;//Буферное звено списка
    int el, el1;//Буферные переменные для дальнейшей работы со списком

    A.BuiltRing();//Строим список
    cout << "Содержимое кольца 'по часовой стрелке': \n";
    A.VyvodLeftRight();//Содержимое кольца 'по часовой стрелке
    cout << "Содержимое кольца'против часовой стрелки': \n";
    A.VyvodRightLeft();//Содержимое кольца'против часовой стрелки
    cout << "Введите элемент звена, после которого ";
    cout << "осуществляется вставка: ";
    cin >> el;//элемент полсе которого будет вставка
    cout << "Введите элемент вставляемого звена: ";
    cin >> el1;//само вставляемое значение
    Res = A.SearchRing(el);//поиск звена полсе которого будет вставка
    if (Res != NULL)//если звено найдено то происходит вставка
    {
        A.InsAfter(Res, el1);//вставка после элемента el
        A.VyvodLeftRight();//вывод по часовой стрелке
    }
    else  cout << "Звена с таким элементом в списке нет!\n";
    cout << "Введите элемент звена, перед которым ";
    cout << "осуществляется вставка: ";
    cin >> el;//элемент перед которым будет вставка
    cout << "Введите элемент вставляемого звена: ";
    cin >> el1;//само вставляемое значение
    Res = A.SearchRing(el);//поиск звена перед которым будет вставка
    if (Res != NULL)//если звено найдено происходит вставка
    {
        A.InsBefore(Res, el1);//вставка перед элементом
        A.VyvodLeftRight();//вывод по часовой стрелке
    }
    else  cout << "Звена с таким элементом в списке нет!\n";

    cout << "Введите элемент звена, который ";
    cout << "надо удалить: ";
    cin >> el;//элемент который нужно удалить
    Res = A.SearchRing(el);//поиск звена которое нужно удалить
    if (Res != NULL)//если звено найдено то удаляем его
    {
        A.Delete(Res);//удаление звена res
        A.VyvodLeftRight();//вывод по часовой стрелке
    }
    else  cout << "Звена с таким элементом в списке нет!\n";

    cout << "Введите элемент звена, после которого ";
    cout << "осуществляется удаление: ";
    cin >> el;//ввод элемента после которго будет удаление
    Res = A.SearchRing(el);//поиск элемента после которого будет удаление 
    if (Res != NULL)//если элемент найден то удаляем звено после него
    {
        A.DelAfter(Res);//удаление следующего звено после res
        A.VyvodLeftRight();//вывод списка по часовой стрелке
    }
    else  cout << "Звена с таким элементом в списке нет!\n";
    A.Ochistka();//Полностью удаляем список

    cout << "\n";
    system("PAUSE");
}

void Spisok::BuiltRing()
// Построение двунаправленного кольцевого списка nsp
//          с удаленным заглавным звеном.
// nsp - указатель на заглавное звено списка.
{
    node* r;//объявление звена списка
    int el;//переменная для заполнения информационного поля звена списка
    //Построим заглавное звено кольцевого списка.
    nsp = new(node);//выделяем память для заголовка
    r = nsp;//ставим первое звена на заголовок
    (*nsp).pred = NULL; //ставим указатель на предыдущий на ноль тк звено единственное
    (*nsp).sled = NULL;//ставим указатель на следующий на ноль тк звено единственное
    cout << "Вводите элементы списка: \n";
    cin >> el;//вводим значение звена
    while (el != 0)//пока не будет ввёд ноль будем заполнять список
    {
        (*r).sled = new (node);//выделение памяти для следующего звена
        (*((*r).sled)).pred = r;//ставим указетель pred следующего звена на предудущее звено
        r = (*r).sled;//переводим указатель r на следующее звено
        (*r).sled = NULL;//ставим пока что указатель sled на ноль , тк он пока что последний
        (*r).elem = el;//заполняем информационное поле звена
        cin >> el;//вводим значение звена
    }
    //А теперь - образуем кольцевой список!
    if ((*nsp).sled != NULL)//если список не пустой
    {
        (*((*nsp).sled)).pred = r;//ставим указетль pred заголовка на поcледний элемент
        (*r).sled = (*nsp).sled;//ставим указатель next последнего элемента на заголовок
    }
    else
        cout << "Кольцевой список пуст!\n";
}

void Spisok::VyvodLeftRight()
// Вывод содержимого двунаправленного кольцевого списка
// с удаленным заглавным звеном "по часовой стрелке".
// nsp - указатель на заглавное звено списка.
{
    node* r;//указатель на одно звено списка с помощью которго мы будем ходить по списку

    cout << "Кольцевой список: ";
    if ((*nsp).sled != NULL)//если список не пустой
    {
        cout << (*((*nsp).sled)).elem << " ";//выводим первый элемент спсика следующий за заголовком
        r = (*((*nsp).sled)).sled;//переводим указатель r на следующее звено
        while (r != (*nsp).sled)//пока не достигнем звена на которое указывает заголовок выводим элементы
        {
            cout << (*r).elem << " "; //вывод элемента
            r = (*r).sled;//переход к следующему элемменту списка
        }
        cout << endl;//переход на новую строку
    }
    else cout << "пуст!";
}

void Spisok::VyvodRightLeft()
// Вывод содержимого двунаправленного кольцевого списка
// с удаленным заглавным звеном "против часовой стрелки".
// nsp - указатель на заглавное звено списка.
{
    node* r;//указатель на одно звено списка с помощью которго мы будем ходить по списку

    cout << "Кольцевой список: ";
    if ((*nsp).sled != NULL)//если список не пустой 
    {
        cout << (*((*((*nsp).sled)).pred)).elem << " ";//вывод самого полследнего элемента
        r = (*((*((*nsp).sled)).pred)).pred;//ставим указтель на предыдущий за последним элементом
        while (r != (*((*nsp).sled)).pred)//пока не достигнем звена на которое указывает заголовок
        {
            cout << (*r).elem << " "; //вывод элемента
            r = (*r).pred;//переход к предыдущему звену
        }
        cout << endl;//переход к следующему звену
    }
    else cout << "пуст!";
}

node* Spisok::SearchRing(int el)
// Поиск элемента el в кольцевом двунаправленном списке
//             с удаленным заглавным звеном.
// nsp - указатель на заглавное звено списка.
{
    node* q;//указатель на звено с помощью котрого будем ходит по списку
    node* p;//указатель на самое первое звено
    node* Res;//указатель на найденное звено

    Res = NULL; //по умолчанию res равен нулю пока не бует надено звено
    p = nsp;//p будет указывать сначала на заголовок
    if ((*((*p).sled)).elem == el)//если первый элемент равен нужному значению
        Res = (*p).sled;//присваиваем res адрес на самый первый элемент
    else
    {
        q = (*((*p).sled)).sled;//переход ко второму элементу списка
        while (q != (*p).sled && Res == NULL)//пока мы не достигнем звена на котрое указывает заголовок и не будет найдено нужное звено
            if ((*q).elem == el)//если звено имеет нужное значение
                Res = q;//присваиваем адрес нужного звена указателю res
            else  
                q = (*q).sled;//переходм к следующему звену
    }
    return Res;//возвращаем адрес найденного звена
}

void Spisok::InsAfter(node* Res, int el)
// Вставление в кольцевой двунаправленный список звена
// с информационным полем el после  звена, на  которое
// указывает ссылка Res.
{
    node* q;//Объявление вставляемого элемента

    q = new(node);//Выделение памяти для вставляемого элемента
    (*q).elem = el; //Заполнение информационного поля вставляемого звена 
    (*q).sled = (*Res).sled;//Направление указателя sled вставляемого элемента на следующий элемент за звеном res
    (*q).pred = (*(*Res).sled).pred;//Направление указателя pred вставляемого элемента на предыдущий за вставляемым элементом
    (*(*Res).sled).pred = q;//Направление указателя pred, следующего за вставляемым звено, на само вставляемое звено
    (*Res).sled = q;//направление указателя sled звена res на вставляемое звено
}

void Spisok::InsBefore(node* Res, int el)
// Вставка в кольцевой двунаправленный список звена
// с информационным полем el перед звеном, на  которое
// указывает ссылка Res.
// nsp - указатель на заглавное звено списка.
{
    node* q;//Объявление вставляемого элемента

    q = new(node);//Выделение памяти для вставляемого элемента
    (*q).elem = el;//Заполнение информационного поля вставляемого звена 
    (*q).sled = (*(*Res).pred).sled;//Направление указателя sled вставляемого звена на звено Res,т.к мы вставляем звено после Res
    (*q).pred = (*Res).pred;//Направление указателя pred вставляемого элемента на предыдущее звено за звеном Res
    (*(*Res).pred).sled = q;//Направление указаетеля sled звена предыдущего за Res на вставляемый элемент
    (*Res).pred = q;//Направление уазателя pred звена Res на вставляемый элемент
    if (Res == (*nsp).sled) //Если нужно вставить элемент перед первым элементом списка на которое указывает заголовок
        (*nsp).sled = q;//Направление указателя sled заголовочного звена на вставляемый элемент
}

void Spisok::Delete(node* Res)
// Удаление из кольцевого двунаправленного списка
// звена, на которое указывает ссылка Res.
// nsp - указатель на заглавное звено списка.
{
    if ((*Res).sled == Res)//Если указатель sled звена Res указывает сам на себя, то есть он состоит из одного звена
    {
        (*nsp).sled = NULL;//Переводим указетля заголовка на ноль
        delete Res;//Удаляем звено из памяти
    }
    else
    {
        (*(*Res).sled).pred = (*Res).pred;//Направление указателя pred звена следующего за Res на предыдущий за звеном Res
        (*(*Res).pred).sled = (*Res).sled;//Направление указателя sled звена предыдущего за Res на следующее за звеном Res
        if ((*nsp).sled == Res)//Если нужно удалить первое звено
            (*nsp).sled = (*Res).sled;//направление указателя sled заголовка на следующее звено за Res
        delete Res;//Освождение памяти удаляемого элемента
    }
}

void Spisok::DelAfter(node* Res)
// Удаление из кольцевого двунаправленного списка звена,
// расположенного  после  звена, на  которое  указывает
// ссылка Res.
// nsp - указатель на заглавное звено списка.
{
    node* q;//указатель на следующее звено которое нужно удалить (которое идет перед звеном Res)

    if ((*Res).sled == Res)//если указатель sled звена res указывает сам на себя, то он состоит из одного звена
    {
        (*nsp).sled = NULL;//Присваиваем указателю sled заголовка на ноль т.к мы удалям единственное звено
        delete Res;//Освбождение памяти удаляемого звена
    }
    else
    {
        q = (*Res).sled;//Переводим звено на следующее звено за Res
        (*(*(*Res).sled).sled).pred = (*(*Res).sled).pred;//Направление указателя pred следующего за удаляемым звеном на предыдущее за удаляемым звеном
        (*Res).sled = (*(*Res).sled).sled;//Направление указателя sled звена Res на следующее звено  за удаляемым звеном 
        if ((*(*nsp).sled).pred == Res)//Если удаляем последнее звено
            // Удаляем "последнее" звено кольца.
            (*nsp).sled = (*Res).sled;//Направляем указатель sled на следующее звено за Res 
        delete q;//Освобождаем память удаляемого звена
    }
}

void Spisok::Ochistka()
{
    node* q;//Указатель на текущее звено
    node* q1;//Опережающий на одно звено указатель

    q = (*((*nsp).sled)).sled;//Устанавливаем указатель на первое звено
    q1 = (*q).sled;//Устанавливаем опережающей указатель
    while (q1 != (*((*nsp).sled)).sled)//Если опережающий указатель равен второму звену
    {
        delete q;//Освождаем память удаляемого элемента
        q = q1;//Устанавливаем текущего указателя на опередающего
        q1 = (*q1).sled;//Устанавливаем опрежающий указтель на следующий
    }
    delete q;//Удаляем оставший указтель
    delete nsp;//Удаляем заголовок
}
