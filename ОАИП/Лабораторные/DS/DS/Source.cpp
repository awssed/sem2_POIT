#include <iostream>
using namespace std;

struct node//Струутура звена двунаправленного списка
{
    int elem;//Информационное поле
    node* sled;//Указатель на следующее звено
    node* pred;//Указатель на предыдущее звено 
};
class Spisok//Класс содержащий функции(методы) и переменные для работы с двусвязным списком
{
private://
    node* nsp, * ksp;//Указатели на конец (ksp) и начало (nsp) двусвязного списка
public://
    Spisok() { nsp = ksp = NULL; }//В начале, когда список не был построен указатель на начало и конец равен нулю
    void Postroenie();//Функция построение двусвязного спсика
    void VyvodForward();//Вывод в той последовательности в которой информация была введена 
    void VyvodBack();//Вывод списка в обратной последовательности
    void Ochistka();//Полная очистка двусвязного списка
    void InsAfter(int, node*);//Вставка звена с информационным полем el в двунаправленный список, заданный указателями nsp и ksp, после звена, на которое указывает Res.
    void InsBefore(int, node*);//Вставка звена с информационным полем el в двунаправленный список, заданный указателями nsp и ksp, перед звеном, на которое указывает Res.
    void Delete(node*);//Удаление звена из двунаправленного списка.nsp - указатель на начало списка, ksp - указатель на конец списка, Res - указатель на удаляемое звено.
    void DelAfter(node*); //Удаление звена из двунаправленного списка. nsp - указатель на начало списка, ksp - указатель на конец списка, Res - указатель на звено, предыдущее удаляемому.
    node* PoiskForward(int);//Функция возвращает указатель на найденный элемент el двунаправленного списка, заданного указателями  nsp и ksp, или NULL, если элемент в списке не найден.
    node* PoiskBack(int);//Функция возвращает указатель на найденный элемент el двунаправленного списка, заданного указателями  nsp и ksp, или NULL, если элемент в списке не найден.
};
void main()
{
    setlocale(LC_ALL, "Rus");//Устанавливаем руский языковой стандарт
    Spisok A;//Объявление двунаправленнного списка А
    node* Res;//Указатель на звено для следующей работы с двунаправленным списком
    int el;//Объявление элемент звена после которого осуществляется вставка
    int el1;//Объявление элемент вставляемого звена

    A.Postroenie();//Построение списка А
    A.VyvodForward();//Вывод в прямом порядке
    A.VyvodBack();//Вывод в обратном порядке

    cout << "Введите элемент звена, после которого ";
    cout << "осуществляется вставка: ";
    cin >> el;//Инициализация элемента звена после которого осуществляется вставка
    cout << "Введите элемент вставляемого звена: ";
    cin >> el1;//Инилициализация элемента вставляемого звенс
    Res = A.PoiskForward(el);//Поиск звена после которого будет осуществляется вставка и запись указателя на это звено в Res
    if (Res != NULL)//Если звено найдено то указаетль не будет равен нулю
    {
        A.InsAfter(el1, Res);//;//Вставка звена с информационным полем el в двунаправленный список, заданный указателями nsp и ksp, после звена, на которое указывает Res.
        A.VyvodForward();// Вывод в той последовательности в которой информация была введена 
        A.VyvodBack();//Вывод списка в обратной последовательности
    }
    else  cout << "Звена с заданным элементом в списке нет!\n";

    cout << "Введите элемент звена, перед которым ";
    cout << "осуществляется вставка: ";
    cin >> el;//Инициализация звена перед которым будет вставлен el1
    cout << "Введите элемент вставляемого звена: ";
    cin >> el1;//Инициализация вставляемого элемента
    Res = A.PoiskBack(el);//Поиск звена перед которым будет вставлен элемент el1 и присваивание его адреса указателю Res
    if (Res != NULL)//Если найдено звено перед которым будет вставка то его значение не будет равно нулю
    {
        A.InsBefore(el1, Res);//Вставка звена с информационным полем el в двунаправленный список, заданный указателями nsp и ksp, перед звеном, на которое указывает Res.
        A.VyvodForward();//Вывод в той последовательности в которой информация была введена 
        A.VyvodBack();//Вывод списка в обратной последовательности
    }
    else  cout << "Звена с заданным элементом в списке нет!\n";

    cout << "Введите элемент звена, после которого ";
    cout << "осуществляется удаление: ";
    cin >> el;//Ввод элемента для поиска
    Res = A.PoiskForward(el);//Функция возвращает указатель на найденный элемент el двунаправленного списка, заданного указателями  nsp и ksp, или NULL, если элемент в списке не найден.
    if (Res != NULL)//Если элемент найден то его указатель не будет равен нулю
    {
        A.DelAfter(Res);//Удаление звена из двунаправленного списка. nsp - указатель на начало списка, ksp - указатель на конец списка, Res - указатель на звено, предыдущее удаляемому.
        A.VyvodForward(); //Вывод в той последовательности в которой информация была введена 
        A.VyvodBack();//Вывод списка в обратной последовательности
    }
    else  cout << "Звена с заданным элементом в списке нет!\n";

    cout << "Введите элемент звена, которое ";
    cout << "надо удалить: ";
    cin >> el;// Инициализация элемента для поиска
    Res = A.PoiskForward(el);////Функция возвращает указатель на найденный элемент el двунаправленного списка, заданного указателями  nsp и ksp, или NULL, если элемент в списке не найден.
    if (Res != NULL)//Если элемент найден то его указатель не будет равен нулю
    {
        A.Delete(Res);//Удаление звена из двунаправленного списка.nsp - указатель на начало списка, ksp - указатель на конец списка, Res - указатель на удаляемое звено.
        A.VyvodForward(); //Вывод в прямом порядке
        A.VyvodBack();//Вывод в обратном порядке
    }
    else  cout << "Звена с заданным элементом в списке нет!\n";

    A.Ochistka();//Полная очистка двусвязного списка

    cout << "\n";
    system("PAUSE");
}
void Spisok::Postroenie()
//Построение двунаправленного списка с заглавным звеном:
// nsp - указатель на начало списка,
// ksp - указатель на конец списка.
{
    node* rsp;//Указатель на буферное звено
    int el;//Буферное переменнаня значание котрой мы будем записывать 

    nsp = new(node);//Выделение памяти для буферной переменной
    rsp = nsp;//Т.к у мы только начинаем строить список и он у нас пустой то указатели на начало и на буферную переменную будут одинаковыми
    (*nsp).pred = NULL;//Т.к список состоит из одного элмента то указатель на предыдущее звено равен нулю
    (*nsp).sled = NULL;//Т.к список состоит из одного звена то указатель на предыдущее звено равен нулю
    cout << "Вводите последовательность:\n";
    cin >> el;//Инициализация буферной переменной для инициализации информационного поля звена спсика
    while (el != 0)//Пока не введём ноль 
    {
        (*rsp).sled = new(node);//Выделение память для слудующего звена спсика
        (*((*rsp).sled)).pred = rsp;//указатель на предыдущий будет равен последнему инициализированному звену
        rsp = (*rsp).sled;//переводим указетль rsp на следующее звено
        (*rsp).sled = NULL; //т.к следующее звено еще невведено оставляем указатель нас ледующий элемент равным нулю
        (*rsp).elem = el;//заполняем информационное поле последнего звена
        cin >> el;//вводим значение информационного поля следующего звена
    }
    ksp = rsp;//полс езаполнения конец перенаправляем на последний введённый элемент
}

void Spisok::VyvodForward()
//Вывод содержимого двунаправленного списка от его начала.
// nsp - указатель на начало списка, ksp - указатель на конец списка.
{
    node* rsp;//Объявление буферного звена в которую будут записывать по очереди звень по отдельностти и позже выводится
    rsp = (*nsp).sled;//запись в буферную переменную первое звено с начала
    cout << "Двунаправленный список содержит: ";
    while (rsp != NULL)//Пока не достигнем конца списка будем записывать звенья в буферную переменную и выводить их
    {
        cout << (*rsp).elem << " "; //Вывод информционного поля звена
        rsp = (*rsp).sled;//Присваивание бйферному указателю значение адреса следующего звена в списке
    }
    cout << endl;//переход на новую строку
}

void Spisok::VyvodBack()
//Вывод содержимого двунаправленного списка от его конца.
// nsp - указатель на начало списка, ksp - указатель на конец списка.
{
    node* rsp;//Объявление буферного звена в которую будут записывать по очереди звень по отдельностти и позже выводится

    rsp = ksp;//Присваимаем буферному указателю значение адреса последнего звена
    cout << "Двунаправленный список в обратном порядке: ";
    while ((*rsp).pred != NULL)//Пока не достигнем самого первого звена значение которого на предыдущее звено равен нулю будем идти по списку и выводить информационные поля звеньев
    {
        cout << (*rsp).elem << " ";//вывод информационного поля звена
        rsp = (*rsp).pred;//присвоение буферному указателю адрес предыдущего звена
    }
    cout << endl;//Переход на новую строку
}

node* Spisok::PoiskForward(int el)
//Функция возвращает указатель на найденный элемент el
//двунаправленного списка, заданного указателями  nsp
// и ksp, или NULL, если элемент в списке не найден.
{
    node* q;//указатель на звено в списке с помощью которого будем ходить по списку
    node* Res;//указатель на найденное звено

    Res = NULL;//сначала пока не начан поиск указатель Res будет равен нулю
    q = (*nsp).sled;//перевод указетель q на первое звено с начала
    while (q != NULL && Res == NULL)//пока не достигнем конца и не будет найдено нужное звено будем идти по списку
        if ((*q).elem == el) Res = q;//если значение информационного поля будет равно нужно значению el
        else  q = (*q).sled;//если информационное поле не равно нужному значению el то переходим к следующему звену
    return Res;//возврыщаем адрес на найденное звено
}
node* Spisok::PoiskBack(int el)
//Функция возвращает указатель на найденный элемент el
//двунаправленного списка, заданного указателями  nsp
// и ksp, или NULL, если элемент в списке не найден.
{
    node* q;//указатель на звено в списке с помощью которого будем ходить по списку
    node* Res;//указатель на найденное звено

    Res = NULL;//сначала пока не начан поиск указатель Res будет равен нулю
    q = ksp;//ставим указатель q на последний элемент в списке
    while (q != NULL && Res == NULL)//пока не достигнем конца и не будет найдено нужное звено будем идти по списку
        if ((*q).elem == el) Res = q;//если значение информационного поля будет равно нужно значению el
        else  q = (*q).pred;//если информационное поле не равно нужному значению el то переходи к предыдущему звену в списке
    return Res;//возвращаем адрес на найденное звено
}

void Spisok::InsAfter(int el, node* Res)
//Вставка звена с информационным полем el в
//в двунаправленный список, заданный указателями
// nsp и ksp, после звена, на которое указывает Res.
{
    node* q; // указатель на новое звено

    q = new(node);//выделяем память для нового элемента которое будем вставлять в список 
    (*q).elem = el;//присваеиваем значение el информационному полю вставляемого элемента
    if ((*Res).sled != NULL)//если звено после, которого нужно вставить звено, не последнее
    {
        (*q).sled = (*Res).sled;//переводим указатель sled нового звена на следующее звено перед звеном Res
        (*q).pred = (*(*Res).sled).pred;//переводим указатель нового звена pred на звено Res
        (*(*Res).sled).pred = q; //переводим указатель следующего за Res на вставляемый элемент
        (*Res).sled = q;//преводим указетль sled звена Res на q
    }
    else//если элемент перед которым нужно вставить элемент полседний
    {
        (*q).sled = NULL;//указатель на следующий элемент вставляемого элемента равен нулю
        (*q).pred = Res; //указтель на предыдущий элемент вставляемого элемента равен адресу Res
        ksp = q;//переводим указетль на конец на вставленный элемент
        (*Res).sled = q;//преводим указатель на следующий элемент Res на вставленный элемент
    }
}

void Spisok::InsBefore(int el, node* Res)
//Вставка звена с информационным полем el в
//в двунаправленный список, заданный указателями
// nsp и ksp, перед звеном, на которое указывает Res.
{
    node* q;//объявляем указатель на новое звено которое будем вставлять
    q = new(node);// выделяем память для нового звена
    (*q).elem = el;//заполняем информационное поле нового звена
    (*q).sled = (*(*Res).pred).sled;//перводим указетль на следующее самого нового звена на следующще за предыдущее звено за Res(то есть на само звено Res)
    (*q).pred = (*Res).pred;//пероводим указетль на предыдущее звено нового звена на предыдущее звено за звеном Res
    (*(*Res).pred).sled = q; //перводим указтатель sled идущее за звеном Res на новое звено
    (*Res).pred = q;//переводим указатель pred звена Res на новое звено
}

void Spisok::Delete(node* Res)
//Удаление звена из двунаправленного списка.
// nsp - указатель на начало списка,
// ksp - указатель на конец списка,
// Res - указатель на удаляемое звено.
{
    if ((*Res).sled != NULL)//Если удаляемый элемент не полследний
    {
        (*(*Res).sled).pred = (*Res).pred;//переводим указатель pred следующего элемента за Res на предыдущий элемент за Res
        (*(*Res).pred).sled = (*Res).sled;//переводим указатель sled предыдущего элемента за Res на следующий элемент за Res
        //тем самым идя по списку мы не будем натыкаться на удаленный элемент и его можно безболезненно удалить из памяти
        delete Res;//удаление из памяти
    }
    else//если элемент последний
    {
        (*(*Res).pred).sled = NULL;//переводим указатель sled предудыщего элемента за Res на ноль т.к он теперь последний
        ksp = (*ksp).pred;//переволим указатель на конец спсика на один элемент назад т.к самый последний элемент удалён
        delete Res;//удаление из памяти
    }
}

void Spisok::DelAfter(node* Res)
//Удаление звена из двунаправленного списка.
// nsp - указатель на начало списка,
// ksp - указатель на конец списка,
// Res - указатель на звено, предыдущее удаляемому.
{
    node* q;//указатель на удаляемый элемент

    if ((*Res).sled == NULL) //если res конечное звено то удаляемого звена не будет существовать
        cout << "Указано последнее звено!\n";
    else//если res не последнее звено
        if ((*(*Res).sled).sled != NULL)//если удаляемое звено не последнее
        {
            q = (*Res).sled;//ставим указатель q на нужное звено
            (*(*(*Res).sled).sled).pred = Res;//перенаправляем указатель pred следующий за удаляемым звеном на Res
            (*Res).sled = (*(*Res).sled).sled;//перенаправляем указатель sled пердыдущего за удаляемым звеном на следующее звено за удаляемым звеном
            delete q;//освобождаем память
        }
        else//если res последнее звено
        {
            q = (*Res).sled; //ставим указатель q на нужное звено
            (*Res).sled = NULL;//преводим указатель sled на ноль, т.к следующее звено будет удалено
            ksp = (*ksp).pred;//переводим указатель на конец списка на оставшийся элемент списка
            delete q;//
        }
}

void Spisok::Ochistka()
//Удаление двунаправленного списка из памяти.
// nsp - указатель на заглавное звено списка,
// ksp - указатель на последнее звено списка.
{
    node* q;//текущий указатель на звено списка
    node* q1;//указатель опрежающий текцщий на одно звено

    q = nsp; //ставим текущий указатель на начало списка
    q1 = (*q).sled;// ставим опережающий указатель на опережающую позицию
    while (q1 != NULL)//пока опережающий указатель не достигнет конца
    {
        q = q1; //смещаем текущий указатель на следуююще звено прирванивая его опережающему
        q1 = (*q1).sled; //смещаем опережающий казатель на одно звено
        delete q;//удаляем память звена на котрое указывает текцщий указатель
    }
    delete nsp;//удаляем звено на которое указывает указатель на начало
    nsp = ksp = NULL;//присваиваем указателям на начало и конец нули т.к мы очистили список
}
