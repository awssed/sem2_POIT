#include <iostream>
using namespace std;

struct node //структура звена дека
{
    int elem;// информационное поле
    node* sled;//указатель на следующее звено
    node* pred;//указатель на предыдущее звено
};

class Spisok//класс содержащий прототипы функции работы с деком
{
private:
    node* nd;//Указатель на начало дека.
    node* kd;//Указатель на конец  дека.
    int klad;//Информационное поле удаленного элемента.
public:
    void BuiltDeck();//функция построения дека
    void VyvodDeck();//функция вывода дека на экран
    void InsLeft(int);//функция вставки элемента слева
    void InsRight(int);//функция вставки элемента справа
    void DelLeft();//функция удаления элемента слева
    void DelRight();//функция йдаления элемента справа
    int Get_Klad() { return klad; }//функция возвращающая значение удаляемого звена для его созранения и последующего использования
    void Ochistka();//полная очистка дека
};

void main()
{
    setlocale(LC_ALL, "Rus");
    Spisok A;//объявление дека
    int el;//объявление буферной переменной для вствки

    A.BuiltDeck();//построение первоначального дека
    A.VyvodDeck();//вывод дека
    cout << "Введите элемент звена, вставляемого справа: ";
    cin >> el;//ввод буферной переменной для вставки её в правый конец дека
    A.InsRight(el);//вствка в правый конец
    A.VyvodDeck();//вывод дека
    cout << "Введите элемент звена, вставляемого слева: ";
    cin >> el; //ввод буферной переменной для вставки её в левый конец дека
    A.InsLeft(el);//вставка элемента в левый конец
    A.VyvodDeck();//вывод дека
    cout << "Удалим звено справа: \n";
    A.DelRight();//удаление элемента в правом конце дека
    A.VyvodDeck();//вывод декв
    cout << "Был удален элемент: " << A.Get_Klad() << endl;//вывод удаленного элемента
    cout << "Удалим звено слева: \n";
    A.DelLeft();//удаление элемента в левом конце дека
    A.VyvodDeck();//вывод дека
    cout << "Был удален элемент: " << A.Get_Klad() << endl;//вывод удаленного элемента
    A.Ochistka();//полная очистка дека

    cout << "\n";//переход на новую строку
    system("PAUSE");
}

void Spisok::BuiltDeck()
// Построение дека на базе двунаправленного
// списка с заглавным звеном.
// nd - указатель на начало дека,
// *kd - указатель на конец дека.
{
    node* q;//буферный указатель для начального звена
    node* z;//буферный указатель для создания новыз звеньев дека
    int  el;//

    nd = new(node);//выделение памяти для элемента в начале дека
    z = nd;//ставим указатель z на начало
    (*nd).pred = (*nd).sled = NULL;//пока что указатели на следующий и предыдущий превого элемента будут равны ноль, т.к другие элементы отсутствуют
    cout << "Введите последовательность: \n";
    cin >> el;//ввод значения первого звена
    while (el != 0)//пока не будет введен 0 будет заполнять дек
    {
        (*z).sled = new (node);//выделение памяти для следующего элемента
        (*((*z).sled)).pred = z;//переаод указателя pred нового звена на текущее предыдущее звено
        z = (*z).sled; //перевод указателя z уже на новое звено
        (*z).sled = NULL;//перевод указтеля sled нового звена на ноль т.к после него нету ещё звеньев
        (*z).elem = el; //заполнение информационного поля звена
        cin >> el;//ввод значения нового звена
    }
    if ((*nd).sled != NULL)//если указатель на начало дека не равен нулю, т.е дек содержит какие-то элементы
    {
        q = nd;//ставим указатель q на начало стека
        nd = (*nd).sled;//перевод указателя на следующее звено для удаления самого первого ненужного пустого звена
        (*nd).pred = NULL;//перевод указателя pred указателя на начало на ноль
        kd = z;//перевод указателя на конец дека на последний введённый элемент
        delete q;//освобождение памяти пустого звена в начале
    }
    else//если не был ввёд какой-либо элемент в дек
    {
        delete nd; //удаление пустого звена в начале
        nd = kd = NULL;//перевод указателей на начало и конец на ноль
    }
}

void Spisok::VyvodDeck()
// Вывод содержимого дека.
// nd - указатель на начало дека.
{
    node* z;//буферный указатель для прохода по деку
    z = nd;//утсановка указателя на начало дека
    cout << "Содержимое дека: ";
    if (z != NULL)//если дек не пустой
        while (z != NULL)//пока не достигнем конца дека будем выводить его звенья
        {
            cout << (*z).elem << " ";//вывод информационного поля звена
            z = (*z).sled;//переход к следущему звену дека
        }
    else //если дек пуст в консоль выводится сообщение о том что он пуст
        cout << "он пуст!\n";
    cout << endl;//переход на новую строку
}
void Spisok::InsLeft(int el)
// Добавление звена, содержащего элемент el, в дек слева.
// nd - указатель на начало дека,
// kd - указатель на конец дека.
{
    node* q;//указатель на вставляемое звено

    q = new(node);//выделение памяти для нового вставляемого элемента
    (*q).elem = el;//заполнение информационного поля вставляемого элемента
    if (nd == NULL)//если дек  пустой, т.е его указатель на начало  равен нулю, происходит вставка в пустой дек
    {
        nd = q; //перевод начального указателя на новый элемент
        (*q).sled = (*q).pred = NULL; //указатели нового вставленого элемента равны нулю, т.к он один в деке
        kd = q;//перевод указателя на конец дека на единственный вставленный элемент
    }
    else//если в деке уже имеются звенья
    {
        (*q).sled = nd;//перевод указателя sled нового звена на самое левое звено(начальное звено)
        (*q).pred = NULL;//перевод указателя pred нового звена на ноль т.к он в начале а значит перед ним нету звеньев
        (*nd).pred = q;//перевод указателя pred следующего за вставленным указателем на новое звено
        nd = q;//перевод начального указателя на новое звено звено,т.к он теперь самый первый
    }
}

void Spisok::InsRight(int el)
// Добавление звена, содержащего элемент el, в дек справа.
// nd - указатель на начало дека,
// kd - указатель на конец дека.
{
    node* q;//объявление указателя на новое вставляемое звено

    q = new(node);//выделение памяти дял нового звена
    (*q).elem = el;//заполнение инфомационного поля новое звена
    if (kd == NULL)////если дек  пустой, т.е его указатель на конец  равен нулю, происходит вставка в пустой дек
    {
        nd = q;//указатель на начало дек переводится на вставляемый элемент
        (*q).sled = (*q).pred = NULL; //указатели нового вставленого элемента равны нулю, т.к он один в деке
        kd = q;//перевод указателя на конец дека но новое звено
    }
    else//елси дек уже имеет звенья
    {
        (*q).sled = NULL;//указатель sled нового звена равен нулю, т.к он последний в деке и заним нету других звеньев
        (*q).pred = kd;//перевод указателя pred нового звена на послденее звено в деке
        (*kd).sled = q;//перевод указателя sled предыдущего указателя за вставляемым на новое звено
        kd = q;//перевод указателя на конец дека новый вставленное звено ,т.к он теперь самый последний в деке
    }
}

void Spisok::DelLeft()
// Удаление звена из дека слева с помещением
// элемента удаляемого звена в переменную klad.
// nd - указатель на начало дека,
// kd - указатель на конец дека.
{
    node* q;//указатель на удаляемое звено

    if ((*nd).sled != NULL)//если звено не единственное в деке
    {
        q = nd;//превод указетеля q на начальный элемент дека, т.к он самый левый
        klad = (*q).elem;//сохрание информации удалемого звена в перменной klad
        nd = (*nd).sled;//превод указателя на начало дека на следующее звено
        (*nd).pred = NULL;//перевод указателя pred начального звена на ноль ,т.к за ним нету больше звеньев
        delete q;//освобождение памяти занятое удаляемым звеном
    }
    else
    { // В деке находится один элемент.
        q = nd;//превод указетеля q на начальный элемент дека, т.к он самый левый и единственный
        klad = (*q).elem;//сохрание информации удалемого звена в перменной klad
        nd = kd = NULL; //указатели на начало и конец равны нулю, т.к после удаления дек будет пустым
        delete q; //освобождение памяти занятое удаляемым звеном
        cout << "Дек пуст!\n";
    }
}

void Spisok::DelRight()
// Удаление звена из дека справа с помещением
// элемента удаляемого звена в переменную klad.
// nd - указатель на начало дека,
// kd - указатель на конец дека.
{
    node* q;//указатель на удаляемое звено

    if ((*kd).pred != NULL)//если в деке несколько звеньев
    {
        q = kd;//превод указетеля q на конечный элемент дека, т.к он самый правый и единственный
        klad = (*q).elem;//сохрание информации удалемого звена в перменной klad
        kd = (*kd).pred;//перевод указателя на конец дека на предыдущее звено за удаляемым звеном
        (*kd).sled = NULL;//указатель sled последнего звено будет теперь равен нулю ,т.к следующий за ним будет удалён
        delete q;//освобождение памяти занятое удаляемым звеном
    }
    else
    {// В деке находится один элемент.
        q = kd;//превод указетеля q на конечный элемент дека, т.к он самый правый и единственный
        klad = (*q).elem;//сохрание информации удалемого звена в перменной klad
        nd = kd = NULL;//указатели на начало и конец равны нулю, т.к после удаления дек будет пустым
        delete q;//освобождение памяти занятое удаляемым звеном
        cout << "Дек пуст!\n";
    }
}

void Spisok::Ochistka()
{
    node* q, * q1;//q-указатель на текущще звено дека, а q1-указатель,который будет опережать текущий на одно звено

    q = nd;//установка текущего указателя на начальное звено дека
    q1 = (*q).sled;//установка опережающего указтеля на звено следющее за текущим
    while (q1 != NULL)//пока опережащий указатель не достигнет конца
    {
        delete q;//освождение памяти занятое звеном , на которое указывает текущий указатель
        q = q1;//перевод текущего указателя на следующее звено путём присваивания ему значения опережающего указателя
        q1 = (*q).sled;//установка опережающего указтеля на звено следющее за текущим
    }
    delete q;//освождение памяти занятое поледний оставшимся звеном
    nd = kd = NULL;//указатели на начало и конец дека теперь равны нулю, т.к теперь дек пустой
}
